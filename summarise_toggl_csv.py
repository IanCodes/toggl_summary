### Python code to read a CSV generated by Toggl and provide summary statistics (and maybe plots)
# currently a regex exact match, but case insensitive

# Pandas provides methods for handling CSV files
import pandas as pd
import argparse
import sys

# Allow use of command line arguments
parser = argparse.ArgumentParser(
    description="Script to read a toggl destailed report output in CSV format. The total time spent on a tag or tags is given."
)
parser.add_argument("-i", "--input", help="toggl detailed report in CSV format")
parser.add_argument("-t", "--tag", help="tag with which to output total time spent, multiple tags can be input as a comma delimited string, e.g. tag1,tag2")
args = parser.parse_args()

# If no arguments are provided
if len(sys.argv) == 1:
    parser.print_help()
    sys.exit(1)

# Function to convert time into seconds and then reformats as HH:MM:SS
# MS copilot suggestion
def format_timedelta_hhhmmss(td: pd.Timedelta) -> str:
    total_seconds = int(td.total_seconds())
    sign = "-" if total_seconds < 0 else ""
    total_seconds = abs(total_seconds)
    hours, rem = divmod(total_seconds, 3600)
    minutes, seconds = divmod(rem, 60)
    return f"{sign}{hours}:{minutes:02d}:{seconds:02d}"

# Read a CSV file into a DataFrame
#df = pd.read_csv('TogglTrack_anonymous_test.csv')
df = pd.read_csv(args.input)
print(f"Reading toggl report: {args.input}")

# Show first few lines of CSV
#print(df.head())

# Show column names
#print(list(df.columns))

# Show tags 
#print(df.Tags)

# The Tags column can have multiple entires separated by a comma.  I want to get time information for individual tags.
# Try exploding tags into their own row
# HOWEVER, explode only works on lists, so convert the Tags field to a list

# Convert Duration to timedelta
# missing values given a value of 0 in the correct time format
df['Duration'] = pd.to_timedelta(df['Duration'], errors="coerce").fillna(pd.Timedelta(0))

# Convert the Tags column from string to list
# lambda represents an anonymous function
df['Tags'] = df['Tags'].apply(lambda x: [tag.strip() for tag in str(x).split(',')])

df_exploded = df.explode('Tags')

# Testing for effect of explosion
#print(f"Length of df {len(df)}")
#print(f"Length of df_exploded {len(df_exploded)}")

# Look through each line of df_exploded
# iterows returns a tuple, so they need unpacking, which can be done using index
#for index, row in df_exploded.iterrows():
#    print(f"Index: {index} Tags: {row['Tags']} Duration: {row['Duration']}")

# Group by tag and sum durations
#df_tag_duration_sum = df_exploded.groupby('Tags')['Duration'].sum()
df_tag_duration_sum = df_exploded.groupby("Tags", as_index=False)["Duration"].sum()

# Apply formatter to allow hours > 24
#df_tag_duration_sum_fmt = df_tag_duration_sum.map(format_timedelta_hhhmmss)
df_tag_duration_sum["Total_HHH_MM_SS"] = df_tag_duration_sum["Duration"].map(format_timedelta_hhhmmss)

# Display whole data frame
#print(df_tag_duration_sum)

# Display selected columns
#print(df_tag_duration_sum[["Tags", "Total_HHH_MM_SS"]].to_string(index=False))

# Display selected tags
#choice = input("Enter a tag (case insensitive), more than one tag via a comma delimited list (e.g. tag1,tag2), or 'All' for all tags: ").lower()
#print(choice)

# Copy tag argument to variable used when input was taken
choice = args.tag
if choice == "all":
    print(df_tag_duration_sum[["Tags", "Total_HHH_MM_SS"]].to_string(index=False))
    total_duration = pd.to_timedelta(df_tag_duration_sum["Total_HHH_MM_SS"]).sum()
    print(f"Total time on all tags: {format_timedelta_hhhmmss(total_duration)}")
else:
    choice_regex = "|".join(choice.split(","))

    # Pattern match (partial match) for user selection is case-sensitive and ignores errors for missing info.
    # print(df_tag_duration_sum[df_tag_duration_sum["Tags"].str.contains(choice_regex, case=False, na=False)][["Tags", "Total_HHH_MM_SS"]].to_string(index=False))    

    # Pattern match (exact match, but case insensitive) for user selection is case-sensitive and ignores errors for missing info.
    # rf = raw formatting, \b = word boundary
    print(df_tag_duration_sum[df_tag_duration_sum["Tags"].str.contains(rf"\b{choice_regex}\b", case=False, na=False, regex=True)][["Tags", "Total_HHH_MM_SS"]].to_string(index=False))    

    # Output total time spent on user selected tags
    df_tag_duration_sum_choice = df_tag_duration_sum[df_tag_duration_sum["Tags"].str.contains(choice_regex, case=False, na=False)][["Tags", "Total_HHH_MM_SS"]]

    choice_duration = pd.to_timedelta(df_tag_duration_sum_choice["Total_HHH_MM_SS"]).sum()
    print(f"Total time on selected tags: {format_timedelta_hhhmmss(choice_duration)}")
